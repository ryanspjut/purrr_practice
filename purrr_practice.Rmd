---
title: "purrr practice"
output:
  html_document:
    df_print: paged
---

The goal is to take an intentionally labored approach to learning the purrr package.  We'll start with a wide set of sample datasets and practice purrr concepts on each dataset.  The plan is to complete ~ 25 drills per concept until the user is fluent with the concept.

```{r load libraries, message=FALSE, warning=FALSE}
library(tidyverse)

```

# Chapter 1

## Getting used to standard map syntax

The map function takes two arguments -- map(data, function).

To start simply, let's start with a dataframe that only has one column:  the disp column of the mtcars dataset.  We'll call this slimmed-down dataset mtcars_disp.


```{r}
mtcars_disp <- mtcars %>% 
  select(disp)

mtcars_disp

```

And we're going to do a very simple operation with this dataset:  we're just going to take the square root of those numbers.

This is an easy thing to do with just the sqrt function, so let's start by just using mutate and the sqrt function.

We haven't gotten to ```purrr``` yet, but this will get our minds thinking and making connections to what ```purrr``` does.
```{r}
mtcars_disp %>% 
  mutate(sqrt_disp = sqrt(disp))
```



Next we're going to use the map function to do the same thing.

The ```map``` function takes two arguments: the data and the function.
The syntax is ```map(data, function)```.

Let's take the square root of the mtcars_disp data using the map function.

To begin, don't use the pipe, just fill in the arguments directly for map(data, function).  You'll notice that the outcome looks a little different than what you had when you used ```mutate```.  Don't worry about that.  Just make sure that the values match (i.e., the first two values are 12.649111, the third value is 10.392305, etc.)

```{r}
map(mtcars_disp, sqrt)
```


Recall that in the tidyverse, you can use the pipe to pass values in as the first argument of functions.  For the next exercises, we'll use the pipe in order to save us the step of creating a new object, which is just a single column of a stored dataset.  To do this with mtcars, we use the following command.

```{r}
mtcars %>% 
  select(disp) %>% 
  map(sqrt)
```

This way we don't have to create a new object called ```mtcars_disp```, and that will help us as we try different datasets.  We don't need to create new single-column objects for each dataset.

Let's do the following exercises.  Importantly, recall that the pipe passes data in as the first argument of the function.  So we are still complying with the ```map(data, function)``` syntax even though the only argument we have inside of ```map``` is the function argument.

As you go through these exercises, notice that each element of the data is treated with the function inside of ```map```.

**these use functions that work on each item in a column**

```{r}
# 1) Using datasets::attitude determine the square root of each value in the rating column.

attitude %>%
  select(rating) %>% 
  map(sqrt)

```
```{r}
# 2) Using datasets::sleep, determine the absolute value of each value in the extra column.

sleep %>% 
  select(extra) %>% 
  map(abs)


```

```{r}
# 3) Using datasets::iris, round of each value in Sepal.Length up using the ceiling function.

iris %>% 
  select(Sepal.Length) %>% 
  map(ceiling)

```

```{r}
# 4) Using datasets::InsectSprays, calculate the cosine of of each value in the count column.

InsectSprays %>% 
  select(count) %>% 
  map(cos)
```

```{r}
# 5) Using datasets::Lobolly round each value in the height column.

Loblolly %>% 
  select(height) %>% 
  map(round)
```


```{r}
# 6) Using datasets::BOD determine the factorial of each value in the Time column.

BOD %>% 
  select(Time) %>% 
  map(factorial)
```


```{r}
# 7) Using datasets::DNase, calculate the sine of each value in the density column.

DNase %>% 
  select(density) %>% 
  map(sin)

```

```{r}
# 8) Using datasets::OrchardSprays, make each value in the treatment column lowercase using str_to_lower.

OrchardSprays %>% 
  select(treatment) %>% 
  map(str_to_lower)
```
```{r}
# 9) Using datasets::esoph, determine the length (number of characters) of each value in the alcgp column.

esoph %>% 
  select(alcgp) %>% 
  map(str_length)
  
```

```{r}
# 10) Using datasets::InsectSprays, determine the square root of each value in the count column.

InsectSprays %>% 
  select(count) %>% 
  map(sqrt)
```
Each of these functions happens to work on just a single value (i.e., square root of a single number, round a single number, make a single letter lowercase).  These functions were chosen for these exercises specifically because they don't act on multiple values together the way a function like ```mean``` does.  The purpose in doing this is to get the sense of passing a single value to a function.  Even though the results return immediately, ```map``` is applying the function to each element of the column being passed to it.


Notice that these all start with dataframes and output vectors.  We'll get to input structures and output structures later.


## Let's use functions that act on multiple values

So we've just been experimenting with functions that take individual values as arguments.  Let's see what happens now as we pass the same data argument to a function like ```mean``` that works on a set of numbers.

```{r}
# 1) Using datasets::attitude determine the mean of the rating column.

attitude %>%
  select(rating) %>% 
  map(mean)

```

```{r}
# 2) Using datasets::sleep determine the median of the extra column.

sleep %>% 
  select(extra) %>% 
  map(median)
```

```{r}
# 3) Using datasets::iris, determine the sum of all values in the Sepal.Length column.

iris %>% 
  select(Sepal.Length) %>% 
  map(sum)
```

```{r}
# 4) Using datasets::InsectSprays calculate the interquartile range of the count column.

InsectSprays %>% 
  select(count) %>% 
  map(IQR)

```

```{r}
# 5) Using tidyr::billboard, identify the maximum value (alphabetically) in the artist column using the max function.

billboard %>% 
  select(artist) %>% 
  map(max)

```
So when your data is a single column, and your function takes a single value as an argument, the function operates on each value of the data.  This is no different than a mutate function.  One important difference, though, is that the input data is a data frame (a column of a dataframe which is also, itself, a dataframe) and the output is a vector.

```{r}



```

